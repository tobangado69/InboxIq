---
alwaysApply: true
---

# Database Rules

Best practices for database design, queries, and management.

## Core Principles

- **Normalization:** Normalize appropriately
- **Indexes:** Index frequently queried fields
- **Transactions:** Use transactions for consistency
- **Migrations:** Version control schema changes

---

## Schema Design

### Normalization

**Normalize appropriately:**
```sql
-- ✅ GOOD: Normalized
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(255),
  email VARCHAR(255)
);

CREATE TABLE orders (
  id INT PRIMARY KEY,
  user_id INT REFERENCES users(id),
  total DECIMAL(10,2)
);

-- ❌ BAD: Denormalized (unless needed for performance)
CREATE TABLE orders (
  id INT PRIMARY KEY,
  user_name VARCHAR(255), -- Should reference users table
  user_email VARCHAR(255),
  total DECIMAL(10,2)
);
```

### Naming Conventions

**Use consistent naming:**
```sql
-- ✅ GOOD: snake_case for tables/columns
CREATE TABLE user_profiles (
  id INT PRIMARY KEY,
  user_id INT,
  created_at TIMESTAMP
);

-- ✅ GOOD: Plural table names
CREATE TABLE users (...);
CREATE TABLE orders (...);
```

---

## Indexes

### Index Frequently Queried Fields

**Create indexes on:**
- Primary keys (automatic)
- Foreign keys
- Frequently filtered columns
- Frequently sorted columns
- Join columns

```sql
-- ✅ GOOD: Index on queried field
CREATE INDEX idx_user_email ON users(email);

-- ✅ GOOD: Composite index for multi-column queries
CREATE INDEX idx_order_user_date ON orders(user_id, created_at);
```

### Don't Over-Index

**Avoid unnecessary indexes:**
- Indexes slow down writes
- Only index what you query
- Monitor index usage

---

## Queries

### Efficient Queries

**Select only needed columns:**
```sql
-- ✅ GOOD: Select specific columns
SELECT id, name, email FROM users WHERE active = true;

-- ❌ BAD: Select all
SELECT * FROM users WHERE active = true;
```

### Avoid N+1 Queries

**Use joins or batch loading:**
```sql
-- ✅ GOOD: Join
SELECT o.*, u.name, u.email
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.user_id = 123;

-- ❌ BAD: N+1 queries
SELECT * FROM orders WHERE user_id = 123;
-- Then for each order:
SELECT * FROM users WHERE id = <order.user_id>;
```

### Use Parameterized Queries

**Prevent SQL injection:**
```javascript
// ✅ GOOD: Parameterized
const query = 'SELECT * FROM users WHERE id = ?';
const user = await db.query(query, [userId]);

// ❌ BAD: String concatenation
const query = `SELECT * FROM users WHERE id = ${userId}`; // Vulnerable!
```

---

## Transactions

### Use Transactions

**Ensure data consistency:**
```javascript
// ✅ GOOD: Transaction
await db.transaction(async (trx) => {
  await trx('users').insert(userData);
  await trx('profiles').insert(profileData);
  // Both succeed or both fail
});
```

### Transaction Scope

**Keep transactions short:**
- Don't hold transactions open
- Don't do external calls in transactions
- Commit quickly

---

## Migrations

### Version Control Schema

**Use migrations:**
```javascript
// ✅ GOOD: Migration
exports.up = function(knex) {
  return knex.schema.createTable('users', function(table) {
    table.increments('id');
    table.string('name');
    table.string('email').unique();
    table.timestamps();
  });
};

exports.down = function(knex) {
  return knex.schema.dropTable('users');
};
```

### Migration Best Practices

- One change per migration
- Reversible migrations
- Test migrations
- Backup before migrations

---

## ORM Usage

### Use ORM When Appropriate

**ORM benefits:**
- Type safety
- Query builder
- Migration support
- Relationship management

**When to use raw SQL:**
- Complex queries
- Performance-critical
- ORM limitations

---

## Performance

### Query Optimization

**Optimize slow queries:**
- Use EXPLAIN to analyze
- Add indexes
- Rewrite inefficient queries
- Use query caching

### Connection Pooling

**Use connection pooling:**
```javascript
// ✅ GOOD: Connection pool
const pool = new Pool({
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});
```

---

## Best Practices Summary

1. **Normalize** - Appropriate normalization
2. **Indexes** - Index frequently queried fields
3. **Efficient Queries** - Select only needed columns
4. **Parameterized** - Prevent SQL injection
5. **Transactions** - Ensure consistency
6. **Migrations** - Version control schema
7. **ORM** - Use when appropriate
8. **Optimize** - Profile and optimize slow queries
9. **Connection Pooling** - Manage connections efficiently
10. **Backup** - Regular backups

---

**Generated by:** `/generate-rules` command  
**Last Updated:** {{DATE}}  
**Project Complexity:** {{COMPLEXITY}}
